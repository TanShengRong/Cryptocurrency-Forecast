#libraries 
library(shiny)
library(tidyverse)
library(dygraphs)
library(xts)
library(rvest)
library(lubridate)
library(forecast)
library(shinythemes)

#read and process file
crypto <- read.csv("crypto-markets.csv", stringsAsFactors = FALSE)
#make it slimmer
crypto <- crypto %>% 
  select(symbol, date, open, close)
#make date as date format
crypto$date <- as.Date(crypto$date)

# Define UI for application 
ui <- navbarPage(
  theme = shinytheme("readable"),
  strong("Cryptography"),
  tabPanel("Interactive Graph", 
   sidebarLayout(
    sidebarPanel(
      "Choose the crypto and the period you're interested in",
      uiOutput("selectCoinsUI"),
      #uiOutput("selectDate")),
      dateRangeInput('selectDate', 'Select date', start = min(crypto$date), end = max(crypto$date))),
    mainPanel(dygraphOutput("priceGraph", width = "100%", height = "800px"))
   )
  ),
  tabPanel("Forecast using BTS", 
           sidebarLayout(
             sidebarPanel(
               uiOutput("selectCryptoWeb"),
               selectInput('selectPriceETS', 'Select Start/End price', choices = c("Open", "Close")), 
               sliderInput("selectHorizonETS",label="How many months to predict?",min=1,max=12,value=2),
               p("We will use the best ETS model(ZZZ) to forecast, display the cross-validated accuracy, parameters, confidence intervals. "),
               p("The optimal training window size is determined between 12-7 months by determining the lowest MAPE obtained per window."),
               p("It might take a few extra seconds to generate the graph.")
             ),
             mainPanel(plotOutput("bestETSForecast", width = "100%", height = "800px"),
                       textOutput("explainETX", container = pre))
           )
  ),
  tabPanel("Other Forecast", 
           h3(strong("Work in Progress...")),
           p("Comparing across cryptos"),
           p("Comparing with actual scraped data from coinmarketcap"),
           p("Plotting the graphs of them")
           ),
  tabPanel("Read Me",
           h3(strong("Reasonings")),
           p("We assume each month has 30 days as we use the userinput of horizon is in months. We would need days as our dataset has daily records"),
           p("Seasonality is ignored as the frequency of the time series is >24. The dataset is daily. Thus the frequency is 365, which represents the number of days in a year"),
           p("We vary the training window from 12-7 months and slides the window by 1-12months to determine the optimal window size for the forecasting."),
           p("The dropdown menu for the cryptocurrencies is dynamically generated by scrapping using rvest on coinmarkeycap"),
           p("The min and max date range in the Interactive Graph changes dynamically for every cryptocurrency as they each have unique ranges."),
           br(),
           h3(strong("Assignment 4, Members:")),
           p("Yani"),
           p("Fiqah"),
           p("Sr")
  )
)

# Define server logic required to draw a histogram
server <- function(input, output, session) {
    
    ##for forecasting
    getDatasetETS <- reactive({
      # get inputs
      selectedCoins <- input$selectCryptoETS
      selectedHorizon <- input$selectHorizonETS
      tmp <- getCryptoListDataFrame()
      if (selectedCoins == "Bitcoin") { selectedCoins = "BTC" }
      else if (selectedCoins == "Ethereum") { selectedCoins = "ETH" }
      else if (selectedCoins == "XRP") { }
      else if (selectedCoins == "Bitcoin Cash") { selectedCoins = "BCH" }
      else if (selectedCoins == "Litecoin") { selectedCoins = "LTC" }
      else if (selectedCoins == "EOS") { }
      else if (selectedCoins == "Binance Coin") { selectedCoins = "BNB" }
      else if (selectedCoins == "Tether") { selectedCoins = "USDT" }
      else if (selectedCoins == "Stellar") { selectedCoins = "XLM" }
      else if (selectedCoins == "Cardano") { selectedCoins = "ADA" }

      #filter by coin
      cryptoData <- crypto[which(crypto$symbol==selectedCoins), ]
      #filter by output
      if (input$selectPriceETS == "Open") { cryptoData <- cryptoData %>% select(open, date) }
      else { cryptoData <- cryptoData %>% select(close, date) }

      #generating TS
      minDate <- ((min(cryptoData$date)))
      maxDate <- ((max(cryptoData$date)))
      cryptoData <- cryptoData %>% select(-c(date)) #drops the date column for TS
      # cryptoTS <- ts(cryptoData, frequency = 365, 
      #                 start = c(year(ymd(minDate)), yday(minDate), 
      #                           end = c(year(ymd(maxDate)),yday(maxDate))))
      minDate <- ymd(minDate) #set the date in ymd format
      maxDate <- ymd(maxDate)
      # 
      # smallestMAPEinW <- 100
      # optimalW <- 0
      # for (i in 0:5) { #windows 3 for test, window 12-i for train
      #   for (j in 0:12) { #13 times, slides for 1 year including current month
      #     tryCatch({
      #       Train <- window(cryptoTS, start = decimal_date(maxDate %m-% months(12+selectedHorizon+j-i)), end = decimal_date((maxDate %m-% months(selectedHorizon+j))))
      #       Test <- window(cryptoTS, start = decimal_date(maxDate %m-% months(selectedHorizon+j)))
      #       #forecast with best window
      #       etsFit <- ets(Train, model = 'ZZZ', damped = FALSE)
      #       #getting MAPE
      #       tmp <- accuracy(forecast(etsFit, h = selectedHorizon * 30), Test)
      #       tmp <- (tmp["Training set", "MAPE"]+tmp["Test set", "MAPE"])/2 #get average of MAPE btwn test and train
      #       if (tmp < smallestMAPEinW) {
      #         #print(paste("changed MAPE")) #debug
      #         smallestMAPEinW <- tmp
      #         optimalW <- i
      #       }
      #     }, error = function(e) { 
      #       #cat("ERROR :",conditionMessage(e), "\n") #debug
      #       })
      #   }
      # }
      # optimalW <- 12-optimalW
      optimalW <- getOptW()
      minDate <- maxDate %m-% months(optimalW)
      cryptoTS <- ts(cryptoData, frequency = 365, 
                     start = c(year(minDate)), yday(minDate), 
                     end = c(year(maxDate),yday(maxDate)))
      cryptoTS
      })
    
    getOptW <- reactive({
      # get inputs
      selectedCoins <- input$selectCryptoETS
      selectedHorizon <- input$selectHorizonETS
      tmp <- getCryptoListDataFrame()
      if (selectedCoins == "Bitcoin") { selectedCoins = "BTC" }
      else if (selectedCoins == "Ethereum") { selectedCoins = "ETH" }
      else if (selectedCoins == "XRP") { }
      else if (selectedCoins == "Bitcoin Cash") { selectedCoins = "BCH" }
      else if (selectedCoins == "Litecoin") { selectedCoins = "LTC" }
      else if (selectedCoins == "EOS") { }
      else if (selectedCoins == "Binance Coin") { selectedCoins = "BNB" }
      else if (selectedCoins == "Tether") { selectedCoins = "USDT" }
      else if (selectedCoins == "Stellar") { selectedCoins = "XLM" }
      else if (selectedCoins == "Cardano") { selectedCoins = "ADA" }
      
      #filter by coin
      cryptoData <- crypto[which(crypto$symbol==selectedCoins), ]
      #filter by output
      if (input$selectPriceETS == "Open") { cryptoData <- cryptoData %>% select(open, date) }
      else { cryptoData <- cryptoData %>% select(close, date) }
      
      #generating TS
      minDate <- ((min(cryptoData$date)))
      maxDate <- ((max(cryptoData$date)))
      cryptoData <- cryptoData %>% select(-c(date)) #drops the date column for TS
      cryptoTS <- ts(cryptoData, frequency = 365, 
                     start = c(year(ymd(minDate)), yday(minDate), 
                               end = c(year(ymd(maxDate)),yday(maxDate))))
      minDate <- ymd(minDate) #set the date in ymd format
      maxDate <- ymd(maxDate)
      
      smallestMAPEinW <- 100
      optimalW <- 0
      for (i in 0:5) { #windows 3 for test, window 12-i for train
        for (j in 0:12) { #13 times, slides for 1 year including current month
          tryCatch({
            Train <- window(cryptoTS, start = decimal_date(maxDate %m-% months(12+selectedHorizon+j-i)), end = decimal_date((maxDate %m-% months(selectedHorizon+j))))
            Test <- window(cryptoTS, start = decimal_date(maxDate %m-% months(selectedHorizon+j)))
            #forecast with best window
            etsFit <- ets(Train, model = 'ZZZ', damped = FALSE)
            #getting MAPE
            tmp <- accuracy(forecast(etsFit, h = selectedHorizon * 30), Test)
            tmp <- (tmp["Training set", "MAPE"]+tmp["Test set", "MAPE"])/2 #get average of MAPE btwn test and train
            if (tmp < smallestMAPEinW) {
              #print(paste("changed MAPE")) #debug
              smallestMAPEinW <- tmp
              optimalW <- i
            }
          }, error = function(e) { 
            #cat("ERROR :",conditionMessage(e), "\n") #debug
          })
        }
      }
      optimalW <- 12-optimalW
      optimalW
    })
    output$explainETX <- renderPrint({
      dataTS <- getDatasetETS()
      print(paste("The optimal window for predicting", input$selectHorizonETS, "months is", getOptW(), "months and the parameters are as follows: "))
      etsFit <- ets(dataTS, model = 'ZZZ',damped = FALSE, na.action = "na.interp")
      summary(etsFit)
    })
    
    output$bestETSForecast <- renderPlot({
      dataTS <- getDatasetETS()
      etsFit <- ets(dataTS, model = 'ZZZ',damped = FALSE, na.action = "na.interp")
      tsDataFC <- forecast(etsFit, h = input$selectHorizonETS * 30)
      autoplot(tsDataFC)
    })  
    
    ##dynamic input from webscrapping 
    getCryptoListDataFrame <- reactive({
      myurl <- read_html("https://coinmarketcap.com") # read our webpage as html
      myurl
      myurlTable <- myurl %>% html_nodes("table#currencies.table") %>% .[[1]]
      myurlTable
      myurlData <- as.data.frame(html_table(myurlTable, header = TRUE)[2])
      myurlData <- myurlData[1:10,]
      myurlData <- gsub("\\n", ",", myurlData)
      myurlData
      myurlData <- strsplit(myurlData, ",")
      print(paste(myurlData))
      print(paste(myurlData[[10]][2]))
      myurlData
    })
    
    output$selectCryptoWeb <- renderUI({
      tmp <- getCryptoListDataFrame()
      selectInput('selectCryptoETS', 'Select crypto(s)', choices = c(
        tmp[[1]][2], tmp[[2]][2], tmp[[3]][2], tmp[[4]][2], tmp[[5]][2], 
        tmp[[6]][2], tmp[[7]][2], tmp[[8]][2], tmp[[9]][2], tmp[[10]][2]))
    })
    
    output$selectCoinsUI <- renderUI({
      tmp <- getCryptoListDataFrame()
      selectInput('selectCoins', 'Select crypto(s)', choices = c(
        tmp[[1]][2], tmp[[2]][2], tmp[[3]][2], tmp[[4]][2], tmp[[5]][2], 
        tmp[[6]][2], tmp[[7]][2], tmp[[8]][2], tmp[[9]][2], tmp[[10]][2]))
    })
    
    getCryptoFilteredDF <- reactive({
      selectedCoins <- input$selectCoins
      
      if (selectedCoins == "Bitcoin") { selectedCoins = "BTC" }
      else if (selectedCoins == "Ethereum") { selectedCoins = "ETH" }
      else if (selectedCoins == "XRP") { }
      else if (selectedCoins == "Bitcoin Cash") { selectedCoins = "BCH" }
      else if (selectedCoins == "Litecoin") { selectedCoins = "LTC" }
      else if (selectedCoins == "EOS") { }
      else if (selectedCoins == "Binance Coin") { selectedCoins = "BNB" }
      else if (selectedCoins == "Tether") { selectedCoins = "USDT" }
      else if (selectedCoins == "Stellar") { selectedCoins = "XLM" }
      else if (selectedCoins == "Cardano") { selectedCoins = "ADA" }
      #filter by coin
      tmpData <- crypto[which(crypto$symbol==selectedCoins), ]
      print(paste("Selected coin is", selectedCoins, str(tmpData), min(tmpData$date)))
      tmpData
    })
  
    ##for interactive open close price
    ###get dataset based on dates
    getDataset <- reactive({
      # # get inputs 
      dates <- input$selectDate
      startDate <- dates[1]
      endDate <- dates[2]
      tmpData <- getCryptoFilteredDF()
      tmpData <- tmpData[which(tmpData$date >= startDate & tmpData$date <= endDate), ]
      tmpData
    })
    ###generate interactive graph
    output$priceGraph <- renderDygraph({
      cryptoData <- getDataset()
      time_series <- xts(cryptoData, order.by = cryptoData$date)
      dygraph(time_series)
    })
    ###get min max and update daterangeinput for user input
    getMinDate <- reactive({
      tmp <- getCryptoFilteredDF()
      tmp <- min(tmp$date)
      print(paste("Min Date is", tmp))
      tmp
    })
    getMaxDate <- reactive({
      tmp <- getCryptoFilteredDF()
      tmp <- max(tmp$date)
      print(paste("Max Date is", tmp))
      tmp
    })
    observeEvent(input$selectCoins, {
      print(paste("observed", getMinDate(), getMaxDate()))
      updateDateRangeInput(session, "selectDate", start = getMinDate(), end = getMaxDate())
    })
    
}
# Run the application 
shinyApp(ui = ui, server = server)
# no more code after this